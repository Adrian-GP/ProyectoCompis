Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    VAR

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM ID SEMICOLON programa2 programa3 main
Rule 2     programa2 -> vars programa2
Rule 3     programa2 -> empty
Rule 4     programa3 -> func programa3
Rule 5     programa3 -> empty
Rule 6     main -> MAIN LBRA mainvars main2 RBRA
Rule 7     main2 -> estatuto main2
Rule 8     main2 -> empty
Rule 9     mainvars -> vars mainvars
Rule 10    mainvars -> empty
Rule 11    vars -> type idmv vars2 SEMICOLON
Rule 12    vars2 -> empty
Rule 13    vars2 -> COMMA idmv vars2
Rule 14    bloque -> LBRA bloque2 RBRA
Rule 15    bloque2 -> empty
Rule 16    bloque2 -> estatuto bloque2
Rule 17    type -> BOOL
Rule 18    type -> CHAR
Rule 19    type -> INT
Rule 20    type -> NUM
Rule 21    exlog -> exlog2 expresion exlog3
Rule 22    exlog2 -> NOT
Rule 23    exlog2 -> empty
Rule 24    exlog3 -> AND exlog
Rule 25    exlog3 -> OR exlog
Rule 26    exlog3 -> empty
Rule 27    expresion -> exp expresion2
Rule 28    expresion2 -> empty
Rule 29    expresion2 -> RELOP exp
Rule 30    estatuto -> estatuto2 SEMICOLON
Rule 31    estatuto2 -> condicion
Rule 32    estatuto2 -> ciclo
Rule 33    estatuto2 -> funccall
Rule 34    estatuto2 -> asignacion
Rule 35    estatuto2 -> read
Rule 36    estatuto2 -> escritura
Rule 37    estatuto2 -> return
Rule 38    asignacion -> idmv EQUALS exlog
Rule 39    data -> NUMERIC
Rule 40    data -> CHARACTER
Rule 41    data -> LOGICAL
Rule 42    data -> INTEGER
Rule 43    data -> idmv
Rule 44    data -> funccall
Rule 45    data -> read
Rule 46    return -> RETURN return2
Rule 47    return2 -> exlog
Rule 48    return2 -> empty
Rule 49    idmvf -> ID idmvf2
Rule 50    idmvf2 -> LSBRA exp RSBRA idmvf3
Rule 51    idmvf2 -> LPAREN exp RPAREN
Rule 52    idmvf2 -> empty
Rule 53    idmvf3 -> LSBRA exp RSBRA
Rule 54    idmvf3 -> empty
Rule 55    idmv -> ID idmv2
Rule 56    idmv2 -> LSBRA exp RSBRA idmvf3
Rule 57    idmv2 -> empty
Rule 58    args -> type ID args2
Rule 59    args2 -> COMMA args
Rule 60    args2 -> empty
Rule 61    funccall -> ID LPAREN funccall2 RPAREN
Rule 62    funccall2 -> exp funccall3
Rule 63    funccall2 -> empty
Rule 64    funccall3 -> COMMA exp funccall3
Rule 65    funccall3 -> empty
Rule 66    condicion -> IF LPAREN exlog RPAREN bloque condicion2
Rule 67    condicion2 -> ELSE bloque
Rule 68    condicion2 -> empty
Rule 69    exp -> term exp2
Rule 70    exp2 -> empty
Rule 71    exp2 -> PLUS exp
Rule 72    exp2 -> MINUS exp
Rule 73    term -> factor term2
Rule 74    term2 -> empty
Rule 75    term2 -> TIMES term
Rule 76    term2 -> DIVIDE term
Rule 77    factor -> LPAREN exlog RPAREN
Rule 78    factor -> PLUS data
Rule 79    factor -> MINUS data
Rule 80    factor -> data
Rule 81    escritura -> WRITE LPAREN interior RPAREN
Rule 82    interior -> expresion escritura2
Rule 83    interior -> CHARACTER escritura2
Rule 84    escritura2 -> COMMA interior
Rule 85    escritura2 -> empty
Rule 86    read -> READ LPAREN read2 RPAREN
Rule 87    read2 -> CHARACTER
Rule 88    read2 -> empty
Rule 89    func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA
Rule 90    functipo -> type
Rule 91    functipo -> VOID
Rule 92    funcargs -> args
Rule 93    funcargs -> empty
Rule 94    funcest -> estatuto funcest
Rule 95    funcest -> empty
Rule 96    funcvars -> vars funcvars
Rule 97    funcvars -> empty
Rule 98    ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
Rule 99    ciclo1 -> asignacion
Rule 100   ciclo1 -> empty
Rule 101   empty -> <empty>

Terminals, with rules where they appear

AND                  : 24
BOOL                 : 17
CHAR                 : 18
CHARACTER            : 40 83 87
COLON                : 
COMMA                : 13 59 64 84
DIVIDE               : 76
ELSE                 : 67
EQUALS               : 38
FOR                  : 98
FUNCTION             : 89
ID                   : 1 49 55 58 61 89
IF                   : 66
INT                  : 19
INTEGER              : 42
LBRA                 : 6 14 89
LOGICAL              : 41
LPAREN               : 51 61 66 77 81 86 89 98
LSBRA                : 50 53 56
MAIN                 : 6
MINUS                : 72 79
NOT                  : 22
NUM                  : 20
NUMERIC              : 39
OR                   : 25
PLUS                 : 71 78
PROGRAM              : 1
RBRA                 : 6 14 89
READ                 : 86
RELOP                : 29
RETURN               : 46
RPAREN               : 51 61 66 77 81 86 89 98
RSBRA                : 50 53 56
SEMICOLON            : 1 11 30 98 98
TIMES                : 75
VAR                  : 
VOID                 : 91
WRITE                : 81
error                : 

Nonterminals, with rules where they appear

args                 : 59 92
args2                : 58
asignacion           : 34 98 99
bloque               : 66 67 98
bloque2              : 14 16
ciclo                : 32
ciclo1               : 98
condicion            : 31
condicion2           : 66
data                 : 78 79 80
empty                : 3 5 8 10 12 15 23 26 28 48 52 54 57 60 63 65 68 70 74 85 88 93 95 97 100
escritura            : 36
escritura2           : 82 83
estatuto             : 7 16 94
estatuto2            : 30
exlog                : 24 25 38 47 66 77 98
exlog2               : 21
exlog3               : 21
exp                  : 27 29 50 51 53 56 62 64 71 72
exp2                 : 69
expresion            : 21 82
expresion2           : 27
factor               : 73
func                 : 4
funcargs             : 89
funccall             : 33 44
funccall2            : 61
funccall3            : 62 64
funcest              : 89 94
functipo             : 89
funcvars             : 89 96
idmv                 : 11 13 38 43
idmv2                : 55
idmvf                : 
idmvf2               : 49
idmvf3               : 50 56
interior             : 81 84
main                 : 1
main2                : 6 7
mainvars             : 6 9
programa             : 0
programa2            : 1 2
programa3            : 1 4
read                 : 35 45
read2                : 86
return               : 37
return2              : 46
term                 : 69 75 76
term2                : 73
type                 : 11 58 90
vars                 : 2 9 96
vars2                : 11 13

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM ID SEMICOLON programa2 programa3 main

    PROGRAM         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAM . ID SEMICOLON programa2 programa3 main

    ID              shift and go to state 3


state 3

    (1) programa -> PROGRAM ID . SEMICOLON programa2 programa3 main

    SEMICOLON       shift and go to state 4


state 4

    (1) programa -> PROGRAM ID SEMICOLON . programa2 programa3 main
    (2) programa2 -> . vars programa2
    (3) programa2 -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    FUNCTION        reduce using rule 101 (empty -> .)
    MAIN            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    programa2                      shift and go to state 5
    vars                           shift and go to state 6
    empty                          shift and go to state 7
    type                           shift and go to state 8

state 5

    (1) programa -> PROGRAM ID SEMICOLON programa2 . programa3 main
    (4) programa3 -> . func programa3
    (5) programa3 -> . empty
    (89) func -> . FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA
    (101) empty -> .

    FUNCTION        shift and go to state 16
    MAIN            reduce using rule 101 (empty -> .)

    programa3                      shift and go to state 13
    func                           shift and go to state 14
    empty                          shift and go to state 15

state 6

    (2) programa2 -> vars . programa2
    (2) programa2 -> . vars programa2
    (3) programa2 -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    FUNCTION        reduce using rule 101 (empty -> .)
    MAIN            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    vars                           shift and go to state 6
    programa2                      shift and go to state 17
    empty                          shift and go to state 7
    type                           shift and go to state 8

state 7

    (3) programa2 -> empty .

    FUNCTION        reduce using rule 3 (programa2 -> empty .)
    MAIN            reduce using rule 3 (programa2 -> empty .)


state 8

    (11) vars -> type . idmv vars2 SEMICOLON
    (55) idmv -> . ID idmv2

    ID              shift and go to state 19

    idmv                           shift and go to state 18

state 9

    (17) type -> BOOL .

    ID              reduce using rule 17 (type -> BOOL .)


state 10

    (18) type -> CHAR .

    ID              reduce using rule 18 (type -> CHAR .)


state 11

    (19) type -> INT .

    ID              reduce using rule 19 (type -> INT .)


state 12

    (20) type -> NUM .

    ID              reduce using rule 20 (type -> NUM .)


state 13

    (1) programa -> PROGRAM ID SEMICOLON programa2 programa3 . main
    (6) main -> . MAIN LBRA mainvars main2 RBRA

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 14

    (4) programa3 -> func . programa3
    (4) programa3 -> . func programa3
    (5) programa3 -> . empty
    (89) func -> . FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA
    (101) empty -> .

    FUNCTION        shift and go to state 16
    MAIN            reduce using rule 101 (empty -> .)

    func                           shift and go to state 14
    programa3                      shift and go to state 22
    empty                          shift and go to state 15

state 15

    (5) programa3 -> empty .

    MAIN            reduce using rule 5 (programa3 -> empty .)


state 16

    (89) func -> FUNCTION . functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA
    (90) functipo -> . type
    (91) functipo -> . VOID
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    VOID            shift and go to state 25
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    functipo                       shift and go to state 23
    type                           shift and go to state 24

state 17

    (2) programa2 -> vars programa2 .

    FUNCTION        reduce using rule 2 (programa2 -> vars programa2 .)
    MAIN            reduce using rule 2 (programa2 -> vars programa2 .)


state 18

    (11) vars -> type idmv . vars2 SEMICOLON
    (12) vars2 -> . empty
    (13) vars2 -> . COMMA idmv vars2
    (101) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 101 (empty -> .)

    vars2                          shift and go to state 26
    empty                          shift and go to state 27

state 19

    (55) idmv -> ID . idmv2
    (56) idmv2 -> . LSBRA exp RSBRA idmvf3
    (57) idmv2 -> . empty
    (101) empty -> .

    LSBRA           shift and go to state 30
    COMMA           reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    EQUALS          reduce using rule 101 (empty -> .)

    idmv2                          shift and go to state 29
    empty                          shift and go to state 31

state 20

    (1) programa -> PROGRAM ID SEMICOLON programa2 programa3 main .

    $end            reduce using rule 1 (programa -> PROGRAM ID SEMICOLON programa2 programa3 main .)


state 21

    (6) main -> MAIN . LBRA mainvars main2 RBRA

    LBRA            shift and go to state 32


state 22

    (4) programa3 -> func programa3 .

    MAIN            reduce using rule 4 (programa3 -> func programa3 .)


state 23

    (89) func -> FUNCTION functipo . ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA

    ID              shift and go to state 33


state 24

    (90) functipo -> type .

    ID              reduce using rule 90 (functipo -> type .)


state 25

    (91) functipo -> VOID .

    ID              reduce using rule 91 (functipo -> VOID .)


state 26

    (11) vars -> type idmv vars2 . SEMICOLON

    SEMICOLON       shift and go to state 34


state 27

    (12) vars2 -> empty .

    SEMICOLON       reduce using rule 12 (vars2 -> empty .)


state 28

    (13) vars2 -> COMMA . idmv vars2
    (55) idmv -> . ID idmv2

    ID              shift and go to state 19

    idmv                           shift and go to state 35

state 29

    (55) idmv -> ID idmv2 .

    COMMA           reduce using rule 55 (idmv -> ID idmv2 .)
    SEMICOLON       reduce using rule 55 (idmv -> ID idmv2 .)
    TIMES           reduce using rule 55 (idmv -> ID idmv2 .)
    DIVIDE          reduce using rule 55 (idmv -> ID idmv2 .)
    PLUS            reduce using rule 55 (idmv -> ID idmv2 .)
    MINUS           reduce using rule 55 (idmv -> ID idmv2 .)
    RSBRA           reduce using rule 55 (idmv -> ID idmv2 .)
    RELOP           reduce using rule 55 (idmv -> ID idmv2 .)
    AND             reduce using rule 55 (idmv -> ID idmv2 .)
    OR              reduce using rule 55 (idmv -> ID idmv2 .)
    RPAREN          reduce using rule 55 (idmv -> ID idmv2 .)
    EQUALS          reduce using rule 55 (idmv -> ID idmv2 .)


state 30

    (56) idmv2 -> LSBRA . exp RSBRA idmvf3
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 36
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 31

    (57) idmv2 -> empty .

    COMMA           reduce using rule 57 (idmv2 -> empty .)
    SEMICOLON       reduce using rule 57 (idmv2 -> empty .)
    EQUALS          reduce using rule 57 (idmv2 -> empty .)
    TIMES           reduce using rule 57 (idmv2 -> empty .)
    DIVIDE          reduce using rule 57 (idmv2 -> empty .)
    PLUS            reduce using rule 57 (idmv2 -> empty .)
    MINUS           reduce using rule 57 (idmv2 -> empty .)
    RSBRA           reduce using rule 57 (idmv2 -> empty .)
    RELOP           reduce using rule 57 (idmv2 -> empty .)
    AND             reduce using rule 57 (idmv2 -> empty .)
    OR              reduce using rule 57 (idmv2 -> empty .)
    RPAREN          reduce using rule 57 (idmv2 -> empty .)


state 32

    (6) main -> MAIN LBRA . mainvars main2 RBRA
    (9) mainvars -> . vars mainvars
    (10) mainvars -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    IF              reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    WRITE           reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    RBRA            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    mainvars                       shift and go to state 52
    vars                           shift and go to state 53
    empty                          shift and go to state 54
    type                           shift and go to state 8

state 33

    (89) func -> FUNCTION functipo ID . LPAREN funcargs RPAREN LBRA funcvars funcest RBRA

    LPAREN          shift and go to state 55


state 34

    (11) vars -> type idmv vars2 SEMICOLON .

    BOOL            reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    CHAR            reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    INT             reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    NUM             reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    FUNCTION        reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    MAIN            reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    IF              reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    FOR             reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    ID              reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    READ            reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    WRITE           reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    RETURN          reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)
    RBRA            reduce using rule 11 (vars -> type idmv vars2 SEMICOLON .)


state 35

    (13) vars2 -> COMMA idmv . vars2
    (12) vars2 -> . empty
    (13) vars2 -> . COMMA idmv vars2
    (101) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 101 (empty -> .)

    vars2                          shift and go to state 56
    empty                          shift and go to state 27

state 36

    (56) idmv2 -> LSBRA exp . RSBRA idmvf3

    RSBRA           shift and go to state 57


state 37

    (69) exp -> term . exp2
    (70) exp2 -> . empty
    (71) exp2 -> . PLUS exp
    (72) exp2 -> . MINUS exp
    (101) empty -> .

    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    RSBRA           reduce using rule 101 (empty -> .)
    RELOP           reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)

    exp2                           shift and go to state 58
    empty                          shift and go to state 59

state 38

    (73) term -> factor . term2
    (74) term2 -> . empty
    (75) term2 -> . TIMES term
    (76) term2 -> . DIVIDE term
    (101) empty -> .

    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    RSBRA           reduce using rule 101 (empty -> .)
    RELOP           reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)

    term2                          shift and go to state 62
    empty                          shift and go to state 63

state 39

    (77) factor -> LPAREN . exlog RPAREN
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 66
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 40

    (78) factor -> PLUS . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    data                           shift and go to state 70
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 41

    (80) factor -> data .

    TIMES           reduce using rule 80 (factor -> data .)
    DIVIDE          reduce using rule 80 (factor -> data .)
    PLUS            reduce using rule 80 (factor -> data .)
    MINUS           reduce using rule 80 (factor -> data .)
    RSBRA           reduce using rule 80 (factor -> data .)
    RELOP           reduce using rule 80 (factor -> data .)
    AND             reduce using rule 80 (factor -> data .)
    OR              reduce using rule 80 (factor -> data .)
    RPAREN          reduce using rule 80 (factor -> data .)
    SEMICOLON       reduce using rule 80 (factor -> data .)
    COMMA           reduce using rule 80 (factor -> data .)


state 42

    (79) factor -> MINUS . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    data                           shift and go to state 71
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 43

    (39) data -> NUMERIC .

    TIMES           reduce using rule 39 (data -> NUMERIC .)
    DIVIDE          reduce using rule 39 (data -> NUMERIC .)
    PLUS            reduce using rule 39 (data -> NUMERIC .)
    MINUS           reduce using rule 39 (data -> NUMERIC .)
    RSBRA           reduce using rule 39 (data -> NUMERIC .)
    RELOP           reduce using rule 39 (data -> NUMERIC .)
    AND             reduce using rule 39 (data -> NUMERIC .)
    OR              reduce using rule 39 (data -> NUMERIC .)
    RPAREN          reduce using rule 39 (data -> NUMERIC .)
    SEMICOLON       reduce using rule 39 (data -> NUMERIC .)
    COMMA           reduce using rule 39 (data -> NUMERIC .)


state 44

    (40) data -> CHARACTER .

    TIMES           reduce using rule 40 (data -> CHARACTER .)
    DIVIDE          reduce using rule 40 (data -> CHARACTER .)
    PLUS            reduce using rule 40 (data -> CHARACTER .)
    MINUS           reduce using rule 40 (data -> CHARACTER .)
    RSBRA           reduce using rule 40 (data -> CHARACTER .)
    RELOP           reduce using rule 40 (data -> CHARACTER .)
    AND             reduce using rule 40 (data -> CHARACTER .)
    OR              reduce using rule 40 (data -> CHARACTER .)
    RPAREN          reduce using rule 40 (data -> CHARACTER .)
    SEMICOLON       reduce using rule 40 (data -> CHARACTER .)
    COMMA           reduce using rule 40 (data -> CHARACTER .)


state 45

    (41) data -> LOGICAL .

    TIMES           reduce using rule 41 (data -> LOGICAL .)
    DIVIDE          reduce using rule 41 (data -> LOGICAL .)
    PLUS            reduce using rule 41 (data -> LOGICAL .)
    MINUS           reduce using rule 41 (data -> LOGICAL .)
    RSBRA           reduce using rule 41 (data -> LOGICAL .)
    RELOP           reduce using rule 41 (data -> LOGICAL .)
    AND             reduce using rule 41 (data -> LOGICAL .)
    OR              reduce using rule 41 (data -> LOGICAL .)
    RPAREN          reduce using rule 41 (data -> LOGICAL .)
    SEMICOLON       reduce using rule 41 (data -> LOGICAL .)
    COMMA           reduce using rule 41 (data -> LOGICAL .)


state 46

    (42) data -> INTEGER .

    TIMES           reduce using rule 42 (data -> INTEGER .)
    DIVIDE          reduce using rule 42 (data -> INTEGER .)
    PLUS            reduce using rule 42 (data -> INTEGER .)
    MINUS           reduce using rule 42 (data -> INTEGER .)
    RSBRA           reduce using rule 42 (data -> INTEGER .)
    RELOP           reduce using rule 42 (data -> INTEGER .)
    AND             reduce using rule 42 (data -> INTEGER .)
    OR              reduce using rule 42 (data -> INTEGER .)
    RPAREN          reduce using rule 42 (data -> INTEGER .)
    SEMICOLON       reduce using rule 42 (data -> INTEGER .)
    COMMA           reduce using rule 42 (data -> INTEGER .)


state 47

    (43) data -> idmv .

    TIMES           reduce using rule 43 (data -> idmv .)
    DIVIDE          reduce using rule 43 (data -> idmv .)
    PLUS            reduce using rule 43 (data -> idmv .)
    MINUS           reduce using rule 43 (data -> idmv .)
    RSBRA           reduce using rule 43 (data -> idmv .)
    RELOP           reduce using rule 43 (data -> idmv .)
    AND             reduce using rule 43 (data -> idmv .)
    OR              reduce using rule 43 (data -> idmv .)
    RPAREN          reduce using rule 43 (data -> idmv .)
    SEMICOLON       reduce using rule 43 (data -> idmv .)
    COMMA           reduce using rule 43 (data -> idmv .)


state 48

    (44) data -> funccall .

    TIMES           reduce using rule 44 (data -> funccall .)
    DIVIDE          reduce using rule 44 (data -> funccall .)
    PLUS            reduce using rule 44 (data -> funccall .)
    MINUS           reduce using rule 44 (data -> funccall .)
    RSBRA           reduce using rule 44 (data -> funccall .)
    RELOP           reduce using rule 44 (data -> funccall .)
    AND             reduce using rule 44 (data -> funccall .)
    OR              reduce using rule 44 (data -> funccall .)
    RPAREN          reduce using rule 44 (data -> funccall .)
    SEMICOLON       reduce using rule 44 (data -> funccall .)
    COMMA           reduce using rule 44 (data -> funccall .)


state 49

    (45) data -> read .

    TIMES           reduce using rule 45 (data -> read .)
    DIVIDE          reduce using rule 45 (data -> read .)
    PLUS            reduce using rule 45 (data -> read .)
    MINUS           reduce using rule 45 (data -> read .)
    RSBRA           reduce using rule 45 (data -> read .)
    RELOP           reduce using rule 45 (data -> read .)
    AND             reduce using rule 45 (data -> read .)
    OR              reduce using rule 45 (data -> read .)
    RPAREN          reduce using rule 45 (data -> read .)
    SEMICOLON       reduce using rule 45 (data -> read .)
    COMMA           reduce using rule 45 (data -> read .)


state 50

    (55) idmv -> ID . idmv2
    (61) funccall -> ID . LPAREN funccall2 RPAREN
    (56) idmv2 -> . LSBRA exp RSBRA idmvf3
    (57) idmv2 -> . empty
    (101) empty -> .

    LPAREN          shift and go to state 72
    LSBRA           shift and go to state 30
    TIMES           reduce using rule 101 (empty -> .)
    DIVIDE          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    RSBRA           reduce using rule 101 (empty -> .)
    RELOP           reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)

    idmv2                          shift and go to state 29
    empty                          shift and go to state 31

state 51

    (86) read -> READ . LPAREN read2 RPAREN

    LPAREN          shift and go to state 73


state 52

    (6) main -> MAIN LBRA mainvars . main2 RBRA
    (7) main2 -> . estatuto main2
    (8) main2 -> . empty
    (30) estatuto -> . estatuto2 SEMICOLON
    (101) empty -> .
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    main2                          shift and go to state 74
    estatuto                       shift and go to state 75
    empty                          shift and go to state 76
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 53

    (9) mainvars -> vars . mainvars
    (9) mainvars -> . vars mainvars
    (10) mainvars -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    IF              reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    WRITE           reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    RBRA            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    vars                           shift and go to state 53
    mainvars                       shift and go to state 91
    empty                          shift and go to state 54
    type                           shift and go to state 8

state 54

    (10) mainvars -> empty .

    IF              reduce using rule 10 (mainvars -> empty .)
    FOR             reduce using rule 10 (mainvars -> empty .)
    ID              reduce using rule 10 (mainvars -> empty .)
    READ            reduce using rule 10 (mainvars -> empty .)
    WRITE           reduce using rule 10 (mainvars -> empty .)
    RETURN          reduce using rule 10 (mainvars -> empty .)
    RBRA            reduce using rule 10 (mainvars -> empty .)


state 55

    (89) func -> FUNCTION functipo ID LPAREN . funcargs RPAREN LBRA funcvars funcest RBRA
    (92) funcargs -> . args
    (93) funcargs -> . empty
    (58) args -> . type ID args2
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    RPAREN          reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    funcargs                       shift and go to state 92
    args                           shift and go to state 93
    empty                          shift and go to state 94
    type                           shift and go to state 95

state 56

    (13) vars2 -> COMMA idmv vars2 .

    SEMICOLON       reduce using rule 13 (vars2 -> COMMA idmv vars2 .)


state 57

    (56) idmv2 -> LSBRA exp RSBRA . idmvf3
    (53) idmvf3 -> . LSBRA exp RSBRA
    (54) idmvf3 -> . empty
    (101) empty -> .

    LSBRA           shift and go to state 96
    COMMA           reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    EQUALS          reduce using rule 101 (empty -> .)
    TIMES           reduce using rule 101 (empty -> .)
    DIVIDE          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    RSBRA           reduce using rule 101 (empty -> .)
    RELOP           reduce using rule 101 (empty -> .)
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)

    idmvf3                         shift and go to state 97
    empty                          shift and go to state 98

state 58

    (69) exp -> term exp2 .

    RSBRA           reduce using rule 69 (exp -> term exp2 .)
    RELOP           reduce using rule 69 (exp -> term exp2 .)
    AND             reduce using rule 69 (exp -> term exp2 .)
    OR              reduce using rule 69 (exp -> term exp2 .)
    RPAREN          reduce using rule 69 (exp -> term exp2 .)
    SEMICOLON       reduce using rule 69 (exp -> term exp2 .)
    COMMA           reduce using rule 69 (exp -> term exp2 .)


state 59

    (70) exp2 -> empty .

    RSBRA           reduce using rule 70 (exp2 -> empty .)
    RELOP           reduce using rule 70 (exp2 -> empty .)
    AND             reduce using rule 70 (exp2 -> empty .)
    OR              reduce using rule 70 (exp2 -> empty .)
    RPAREN          reduce using rule 70 (exp2 -> empty .)
    SEMICOLON       reduce using rule 70 (exp2 -> empty .)
    COMMA           reduce using rule 70 (exp2 -> empty .)


state 60

    (71) exp2 -> PLUS . exp
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 99
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 61

    (72) exp2 -> MINUS . exp
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 100
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 62

    (73) term -> factor term2 .

    PLUS            reduce using rule 73 (term -> factor term2 .)
    MINUS           reduce using rule 73 (term -> factor term2 .)
    RSBRA           reduce using rule 73 (term -> factor term2 .)
    RELOP           reduce using rule 73 (term -> factor term2 .)
    AND             reduce using rule 73 (term -> factor term2 .)
    OR              reduce using rule 73 (term -> factor term2 .)
    RPAREN          reduce using rule 73 (term -> factor term2 .)
    SEMICOLON       reduce using rule 73 (term -> factor term2 .)
    COMMA           reduce using rule 73 (term -> factor term2 .)


state 63

    (74) term2 -> empty .

    PLUS            reduce using rule 74 (term2 -> empty .)
    MINUS           reduce using rule 74 (term2 -> empty .)
    RSBRA           reduce using rule 74 (term2 -> empty .)
    RELOP           reduce using rule 74 (term2 -> empty .)
    AND             reduce using rule 74 (term2 -> empty .)
    OR              reduce using rule 74 (term2 -> empty .)
    RPAREN          reduce using rule 74 (term2 -> empty .)
    SEMICOLON       reduce using rule 74 (term2 -> empty .)
    COMMA           reduce using rule 74 (term2 -> empty .)


state 64

    (75) term2 -> TIMES . term
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    term                           shift and go to state 101
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 65

    (76) term2 -> DIVIDE . term
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    term                           shift and go to state 102
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 66

    (77) factor -> LPAREN exlog . RPAREN

    RPAREN          shift and go to state 103


state 67

    (21) exlog -> exlog2 . expresion exlog3
    (27) expresion -> . exp expresion2
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    expresion                      shift and go to state 104
    exp                            shift and go to state 105
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 68

    (22) exlog2 -> NOT .

    LPAREN          reduce using rule 22 (exlog2 -> NOT .)
    PLUS            reduce using rule 22 (exlog2 -> NOT .)
    MINUS           reduce using rule 22 (exlog2 -> NOT .)
    NUMERIC         reduce using rule 22 (exlog2 -> NOT .)
    CHARACTER       reduce using rule 22 (exlog2 -> NOT .)
    LOGICAL         reduce using rule 22 (exlog2 -> NOT .)
    INTEGER         reduce using rule 22 (exlog2 -> NOT .)
    ID              reduce using rule 22 (exlog2 -> NOT .)
    READ            reduce using rule 22 (exlog2 -> NOT .)


state 69

    (23) exlog2 -> empty .

    LPAREN          reduce using rule 23 (exlog2 -> empty .)
    PLUS            reduce using rule 23 (exlog2 -> empty .)
    MINUS           reduce using rule 23 (exlog2 -> empty .)
    NUMERIC         reduce using rule 23 (exlog2 -> empty .)
    CHARACTER       reduce using rule 23 (exlog2 -> empty .)
    LOGICAL         reduce using rule 23 (exlog2 -> empty .)
    INTEGER         reduce using rule 23 (exlog2 -> empty .)
    ID              reduce using rule 23 (exlog2 -> empty .)
    READ            reduce using rule 23 (exlog2 -> empty .)


state 70

    (78) factor -> PLUS data .

    TIMES           reduce using rule 78 (factor -> PLUS data .)
    DIVIDE          reduce using rule 78 (factor -> PLUS data .)
    PLUS            reduce using rule 78 (factor -> PLUS data .)
    MINUS           reduce using rule 78 (factor -> PLUS data .)
    RSBRA           reduce using rule 78 (factor -> PLUS data .)
    RELOP           reduce using rule 78 (factor -> PLUS data .)
    AND             reduce using rule 78 (factor -> PLUS data .)
    OR              reduce using rule 78 (factor -> PLUS data .)
    RPAREN          reduce using rule 78 (factor -> PLUS data .)
    SEMICOLON       reduce using rule 78 (factor -> PLUS data .)
    COMMA           reduce using rule 78 (factor -> PLUS data .)


state 71

    (79) factor -> MINUS data .

    TIMES           reduce using rule 79 (factor -> MINUS data .)
    DIVIDE          reduce using rule 79 (factor -> MINUS data .)
    PLUS            reduce using rule 79 (factor -> MINUS data .)
    MINUS           reduce using rule 79 (factor -> MINUS data .)
    RSBRA           reduce using rule 79 (factor -> MINUS data .)
    RELOP           reduce using rule 79 (factor -> MINUS data .)
    AND             reduce using rule 79 (factor -> MINUS data .)
    OR              reduce using rule 79 (factor -> MINUS data .)
    RPAREN          reduce using rule 79 (factor -> MINUS data .)
    SEMICOLON       reduce using rule 79 (factor -> MINUS data .)
    COMMA           reduce using rule 79 (factor -> MINUS data .)


state 72

    (61) funccall -> ID LPAREN . funccall2 RPAREN
    (62) funccall2 -> . exp funccall3
    (63) funccall2 -> . empty
    (69) exp -> . term exp2
    (101) empty -> .
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    RPAREN          reduce using rule 101 (empty -> .)
    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    funccall2                      shift and go to state 106
    exp                            shift and go to state 107
    empty                          shift and go to state 108
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 73

    (86) read -> READ LPAREN . read2 RPAREN
    (87) read2 -> . CHARACTER
    (88) read2 -> . empty
    (101) empty -> .

    CHARACTER       shift and go to state 110
    RPAREN          reduce using rule 101 (empty -> .)

    read2                          shift and go to state 109
    empty                          shift and go to state 111

state 74

    (6) main -> MAIN LBRA mainvars main2 . RBRA

    RBRA            shift and go to state 112


state 75

    (7) main2 -> estatuto . main2
    (7) main2 -> . estatuto main2
    (8) main2 -> . empty
    (30) estatuto -> . estatuto2 SEMICOLON
    (101) empty -> .
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    estatuto                       shift and go to state 75
    main2                          shift and go to state 113
    empty                          shift and go to state 76
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 76

    (8) main2 -> empty .

    RBRA            reduce using rule 8 (main2 -> empty .)


state 77

    (30) estatuto -> estatuto2 . SEMICOLON

    SEMICOLON       shift and go to state 114


state 78

    (31) estatuto2 -> condicion .

    SEMICOLON       reduce using rule 31 (estatuto2 -> condicion .)


state 79

    (32) estatuto2 -> ciclo .

    SEMICOLON       reduce using rule 32 (estatuto2 -> ciclo .)


state 80

    (33) estatuto2 -> funccall .

    SEMICOLON       reduce using rule 33 (estatuto2 -> funccall .)


state 81

    (34) estatuto2 -> asignacion .

    SEMICOLON       reduce using rule 34 (estatuto2 -> asignacion .)


state 82

    (35) estatuto2 -> read .

    SEMICOLON       reduce using rule 35 (estatuto2 -> read .)


state 83

    (36) estatuto2 -> escritura .

    SEMICOLON       reduce using rule 36 (estatuto2 -> escritura .)


state 84

    (37) estatuto2 -> return .

    SEMICOLON       reduce using rule 37 (estatuto2 -> return .)


state 85

    (66) condicion -> IF . LPAREN exlog RPAREN bloque condicion2

    LPAREN          shift and go to state 115


state 86

    (98) ciclo -> FOR . LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque

    LPAREN          shift and go to state 116


state 87

    (61) funccall -> ID . LPAREN funccall2 RPAREN
    (55) idmv -> ID . idmv2
    (56) idmv2 -> . LSBRA exp RSBRA idmvf3
    (57) idmv2 -> . empty
    (101) empty -> .

    LPAREN          shift and go to state 72
    LSBRA           shift and go to state 30
    EQUALS          reduce using rule 101 (empty -> .)

    idmv2                          shift and go to state 29
    empty                          shift and go to state 31

state 88

    (38) asignacion -> idmv . EQUALS exlog

    EQUALS          shift and go to state 117


state 89

    (81) escritura -> WRITE . LPAREN interior RPAREN

    LPAREN          shift and go to state 118


state 90

    (46) return -> RETURN . return2
    (47) return2 -> . exlog
    (48) return2 -> . empty
    (21) exlog -> . exlog2 expresion exlog3
    (101) empty -> .
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty

    SEMICOLON       reduce using rule 101 (empty -> .)
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    NOT             shift and go to state 68

    return2                        shift and go to state 119
    exlog                          shift and go to state 120
    empty                          shift and go to state 121
    exlog2                         shift and go to state 67

state 91

    (9) mainvars -> vars mainvars .

    IF              reduce using rule 9 (mainvars -> vars mainvars .)
    FOR             reduce using rule 9 (mainvars -> vars mainvars .)
    ID              reduce using rule 9 (mainvars -> vars mainvars .)
    READ            reduce using rule 9 (mainvars -> vars mainvars .)
    WRITE           reduce using rule 9 (mainvars -> vars mainvars .)
    RETURN          reduce using rule 9 (mainvars -> vars mainvars .)
    RBRA            reduce using rule 9 (mainvars -> vars mainvars .)


state 92

    (89) func -> FUNCTION functipo ID LPAREN funcargs . RPAREN LBRA funcvars funcest RBRA

    RPAREN          shift and go to state 122


state 93

    (92) funcargs -> args .

    RPAREN          reduce using rule 92 (funcargs -> args .)


state 94

    (93) funcargs -> empty .

    RPAREN          reduce using rule 93 (funcargs -> empty .)


state 95

    (58) args -> type . ID args2

    ID              shift and go to state 123


state 96

    (53) idmvf3 -> LSBRA . exp RSBRA
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 124
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 97

    (56) idmv2 -> LSBRA exp RSBRA idmvf3 .

    COMMA           reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    SEMICOLON       reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    EQUALS          reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    TIMES           reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    DIVIDE          reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    PLUS            reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    MINUS           reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    RSBRA           reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    RELOP           reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    AND             reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    OR              reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)
    RPAREN          reduce using rule 56 (idmv2 -> LSBRA exp RSBRA idmvf3 .)


state 98

    (54) idmvf3 -> empty .

    COMMA           reduce using rule 54 (idmvf3 -> empty .)
    SEMICOLON       reduce using rule 54 (idmvf3 -> empty .)
    EQUALS          reduce using rule 54 (idmvf3 -> empty .)
    TIMES           reduce using rule 54 (idmvf3 -> empty .)
    DIVIDE          reduce using rule 54 (idmvf3 -> empty .)
    PLUS            reduce using rule 54 (idmvf3 -> empty .)
    MINUS           reduce using rule 54 (idmvf3 -> empty .)
    RSBRA           reduce using rule 54 (idmvf3 -> empty .)
    RELOP           reduce using rule 54 (idmvf3 -> empty .)
    AND             reduce using rule 54 (idmvf3 -> empty .)
    OR              reduce using rule 54 (idmvf3 -> empty .)
    RPAREN          reduce using rule 54 (idmvf3 -> empty .)


state 99

    (71) exp2 -> PLUS exp .

    RSBRA           reduce using rule 71 (exp2 -> PLUS exp .)
    RELOP           reduce using rule 71 (exp2 -> PLUS exp .)
    AND             reduce using rule 71 (exp2 -> PLUS exp .)
    OR              reduce using rule 71 (exp2 -> PLUS exp .)
    RPAREN          reduce using rule 71 (exp2 -> PLUS exp .)
    SEMICOLON       reduce using rule 71 (exp2 -> PLUS exp .)
    COMMA           reduce using rule 71 (exp2 -> PLUS exp .)


state 100

    (72) exp2 -> MINUS exp .

    RSBRA           reduce using rule 72 (exp2 -> MINUS exp .)
    RELOP           reduce using rule 72 (exp2 -> MINUS exp .)
    AND             reduce using rule 72 (exp2 -> MINUS exp .)
    OR              reduce using rule 72 (exp2 -> MINUS exp .)
    RPAREN          reduce using rule 72 (exp2 -> MINUS exp .)
    SEMICOLON       reduce using rule 72 (exp2 -> MINUS exp .)
    COMMA           reduce using rule 72 (exp2 -> MINUS exp .)


state 101

    (75) term2 -> TIMES term .

    PLUS            reduce using rule 75 (term2 -> TIMES term .)
    MINUS           reduce using rule 75 (term2 -> TIMES term .)
    RSBRA           reduce using rule 75 (term2 -> TIMES term .)
    RELOP           reduce using rule 75 (term2 -> TIMES term .)
    AND             reduce using rule 75 (term2 -> TIMES term .)
    OR              reduce using rule 75 (term2 -> TIMES term .)
    RPAREN          reduce using rule 75 (term2 -> TIMES term .)
    SEMICOLON       reduce using rule 75 (term2 -> TIMES term .)
    COMMA           reduce using rule 75 (term2 -> TIMES term .)


state 102

    (76) term2 -> DIVIDE term .

    PLUS            reduce using rule 76 (term2 -> DIVIDE term .)
    MINUS           reduce using rule 76 (term2 -> DIVIDE term .)
    RSBRA           reduce using rule 76 (term2 -> DIVIDE term .)
    RELOP           reduce using rule 76 (term2 -> DIVIDE term .)
    AND             reduce using rule 76 (term2 -> DIVIDE term .)
    OR              reduce using rule 76 (term2 -> DIVIDE term .)
    RPAREN          reduce using rule 76 (term2 -> DIVIDE term .)
    SEMICOLON       reduce using rule 76 (term2 -> DIVIDE term .)
    COMMA           reduce using rule 76 (term2 -> DIVIDE term .)


state 103

    (77) factor -> LPAREN exlog RPAREN .

    TIMES           reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    DIVIDE          reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    PLUS            reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    MINUS           reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    RSBRA           reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    RELOP           reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    AND             reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    OR              reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    RPAREN          reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    SEMICOLON       reduce using rule 77 (factor -> LPAREN exlog RPAREN .)
    COMMA           reduce using rule 77 (factor -> LPAREN exlog RPAREN .)


state 104

    (21) exlog -> exlog2 expresion . exlog3
    (24) exlog3 -> . AND exlog
    (25) exlog3 -> . OR exlog
    (26) exlog3 -> . empty
    (101) empty -> .

    AND             shift and go to state 126
    OR              shift and go to state 127
    RPAREN          reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)

    exlog3                         shift and go to state 125
    empty                          shift and go to state 128

state 105

    (27) expresion -> exp . expresion2
    (28) expresion2 -> . empty
    (29) expresion2 -> . RELOP exp
    (101) empty -> .

    RELOP           shift and go to state 131
    AND             reduce using rule 101 (empty -> .)
    OR              reduce using rule 101 (empty -> .)
    RPAREN          reduce using rule 101 (empty -> .)
    SEMICOLON       reduce using rule 101 (empty -> .)
    COMMA           reduce using rule 101 (empty -> .)

    expresion2                     shift and go to state 129
    empty                          shift and go to state 130

state 106

    (61) funccall -> ID LPAREN funccall2 . RPAREN

    RPAREN          shift and go to state 132


state 107

    (62) funccall2 -> exp . funccall3
    (64) funccall3 -> . COMMA exp funccall3
    (65) funccall3 -> . empty
    (101) empty -> .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 101 (empty -> .)

    funccall3                      shift and go to state 133
    empty                          shift and go to state 135

state 108

    (63) funccall2 -> empty .

    RPAREN          reduce using rule 63 (funccall2 -> empty .)


state 109

    (86) read -> READ LPAREN read2 . RPAREN

    RPAREN          shift and go to state 136


state 110

    (87) read2 -> CHARACTER .

    RPAREN          reduce using rule 87 (read2 -> CHARACTER .)


state 111

    (88) read2 -> empty .

    RPAREN          reduce using rule 88 (read2 -> empty .)


state 112

    (6) main -> MAIN LBRA mainvars main2 RBRA .

    $end            reduce using rule 6 (main -> MAIN LBRA mainvars main2 RBRA .)


state 113

    (7) main2 -> estatuto main2 .

    RBRA            reduce using rule 7 (main2 -> estatuto main2 .)


state 114

    (30) estatuto -> estatuto2 SEMICOLON .

    IF              reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    FOR             reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    ID              reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    READ            reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    WRITE           reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    RETURN          reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)
    RBRA            reduce using rule 30 (estatuto -> estatuto2 SEMICOLON .)


state 115

    (66) condicion -> IF LPAREN . exlog RPAREN bloque condicion2
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 137
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 116

    (98) ciclo -> FOR LPAREN . ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (99) ciclo1 -> . asignacion
    (100) ciclo1 -> . empty
    (38) asignacion -> . idmv EQUALS exlog
    (101) empty -> .
    (55) idmv -> . ID idmv2

    SEMICOLON       reduce using rule 101 (empty -> .)
    ID              shift and go to state 19

    ciclo1                         shift and go to state 138
    asignacion                     shift and go to state 139
    empty                          shift and go to state 140
    idmv                           shift and go to state 88

state 117

    (38) asignacion -> idmv EQUALS . exlog
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 141
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 118

    (81) escritura -> WRITE LPAREN . interior RPAREN
    (82) interior -> . expresion escritura2
    (83) interior -> . CHARACTER escritura2
    (27) expresion -> . exp expresion2
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    CHARACTER       shift and go to state 144
    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    interior                       shift and go to state 142
    expresion                      shift and go to state 143
    exp                            shift and go to state 105
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 119

    (46) return -> RETURN return2 .

    SEMICOLON       reduce using rule 46 (return -> RETURN return2 .)


state 120

    (47) return2 -> exlog .

    SEMICOLON       reduce using rule 47 (return2 -> exlog .)


state 121

    (48) return2 -> empty .
    (23) exlog2 -> empty .

    SEMICOLON       reduce using rule 48 (return2 -> empty .)
    LPAREN          reduce using rule 23 (exlog2 -> empty .)
    PLUS            reduce using rule 23 (exlog2 -> empty .)
    MINUS           reduce using rule 23 (exlog2 -> empty .)
    NUMERIC         reduce using rule 23 (exlog2 -> empty .)
    CHARACTER       reduce using rule 23 (exlog2 -> empty .)
    LOGICAL         reduce using rule 23 (exlog2 -> empty .)
    INTEGER         reduce using rule 23 (exlog2 -> empty .)
    ID              reduce using rule 23 (exlog2 -> empty .)
    READ            reduce using rule 23 (exlog2 -> empty .)


state 122

    (89) func -> FUNCTION functipo ID LPAREN funcargs RPAREN . LBRA funcvars funcest RBRA

    LBRA            shift and go to state 145


state 123

    (58) args -> type ID . args2
    (59) args2 -> . COMMA args
    (60) args2 -> . empty
    (101) empty -> .

    COMMA           shift and go to state 147
    RPAREN          reduce using rule 101 (empty -> .)

    args2                          shift and go to state 146
    empty                          shift and go to state 148

state 124

    (53) idmvf3 -> LSBRA exp . RSBRA

    RSBRA           shift and go to state 149


state 125

    (21) exlog -> exlog2 expresion exlog3 .

    RPAREN          reduce using rule 21 (exlog -> exlog2 expresion exlog3 .)
    SEMICOLON       reduce using rule 21 (exlog -> exlog2 expresion exlog3 .)


state 126

    (24) exlog3 -> AND . exlog
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 150
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 127

    (25) exlog3 -> OR . exlog
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 151
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 128

    (26) exlog3 -> empty .

    RPAREN          reduce using rule 26 (exlog3 -> empty .)
    SEMICOLON       reduce using rule 26 (exlog3 -> empty .)


state 129

    (27) expresion -> exp expresion2 .

    AND             reduce using rule 27 (expresion -> exp expresion2 .)
    OR              reduce using rule 27 (expresion -> exp expresion2 .)
    RPAREN          reduce using rule 27 (expresion -> exp expresion2 .)
    SEMICOLON       reduce using rule 27 (expresion -> exp expresion2 .)
    COMMA           reduce using rule 27 (expresion -> exp expresion2 .)


state 130

    (28) expresion2 -> empty .

    AND             reduce using rule 28 (expresion2 -> empty .)
    OR              reduce using rule 28 (expresion2 -> empty .)
    RPAREN          reduce using rule 28 (expresion2 -> empty .)
    SEMICOLON       reduce using rule 28 (expresion2 -> empty .)
    COMMA           reduce using rule 28 (expresion2 -> empty .)


state 131

    (29) expresion2 -> RELOP . exp
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 152
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 132

    (61) funccall -> ID LPAREN funccall2 RPAREN .

    TIMES           reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    DIVIDE          reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    PLUS            reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    MINUS           reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    RSBRA           reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    RELOP           reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    AND             reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    OR              reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    RPAREN          reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    SEMICOLON       reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)
    COMMA           reduce using rule 61 (funccall -> ID LPAREN funccall2 RPAREN .)


state 133

    (62) funccall2 -> exp funccall3 .

    RPAREN          reduce using rule 62 (funccall2 -> exp funccall3 .)


state 134

    (64) funccall3 -> COMMA . exp funccall3
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    CHARACTER       shift and go to state 44
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    exp                            shift and go to state 153
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 135

    (65) funccall3 -> empty .

    RPAREN          reduce using rule 65 (funccall3 -> empty .)


state 136

    (86) read -> READ LPAREN read2 RPAREN .

    TIMES           reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    DIVIDE          reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    PLUS            reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    MINUS           reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    RSBRA           reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    RELOP           reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    AND             reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    OR              reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    RPAREN          reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    SEMICOLON       reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)
    COMMA           reduce using rule 86 (read -> READ LPAREN read2 RPAREN .)


state 137

    (66) condicion -> IF LPAREN exlog . RPAREN bloque condicion2

    RPAREN          shift and go to state 154


state 138

    (98) ciclo -> FOR LPAREN ciclo1 . SEMICOLON exlog SEMICOLON asignacion RPAREN bloque

    SEMICOLON       shift and go to state 155


state 139

    (99) ciclo1 -> asignacion .

    SEMICOLON       reduce using rule 99 (ciclo1 -> asignacion .)


state 140

    (100) ciclo1 -> empty .

    SEMICOLON       reduce using rule 100 (ciclo1 -> empty .)


state 141

    (38) asignacion -> idmv EQUALS exlog .

    SEMICOLON       reduce using rule 38 (asignacion -> idmv EQUALS exlog .)
    RPAREN          reduce using rule 38 (asignacion -> idmv EQUALS exlog .)


state 142

    (81) escritura -> WRITE LPAREN interior . RPAREN

    RPAREN          shift and go to state 156


state 143

    (82) interior -> expresion . escritura2
    (84) escritura2 -> . COMMA interior
    (85) escritura2 -> . empty
    (101) empty -> .

    COMMA           shift and go to state 158
    RPAREN          reduce using rule 101 (empty -> .)

    escritura2                     shift and go to state 157
    empty                          shift and go to state 159

state 144

    (83) interior -> CHARACTER . escritura2
    (40) data -> CHARACTER .
    (84) escritura2 -> . COMMA interior
    (85) escritura2 -> . empty
    (101) empty -> .

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 40 (data -> CHARACTER .)
    TIMES           reduce using rule 40 (data -> CHARACTER .)
    DIVIDE          reduce using rule 40 (data -> CHARACTER .)
    PLUS            reduce using rule 40 (data -> CHARACTER .)
    MINUS           reduce using rule 40 (data -> CHARACTER .)
    RELOP           reduce using rule 40 (data -> CHARACTER .)
    RPAREN          reduce using rule 40 (data -> CHARACTER .)
    COMMA           shift and go to state 158

  ! COMMA           [ reduce using rule 40 (data -> CHARACTER .) ]
  ! RPAREN          [ reduce using rule 101 (empty -> .) ]

    escritura2                     shift and go to state 160
    empty                          shift and go to state 159

state 145

    (89) func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA . funcvars funcest RBRA
    (96) funcvars -> . vars funcvars
    (97) funcvars -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    IF              reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    WRITE           reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    RBRA            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    funcvars                       shift and go to state 161
    vars                           shift and go to state 162
    empty                          shift and go to state 163
    type                           shift and go to state 8

state 146

    (58) args -> type ID args2 .

    RPAREN          reduce using rule 58 (args -> type ID args2 .)


state 147

    (59) args2 -> COMMA . args
    (58) args -> . type ID args2
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    args                           shift and go to state 164
    type                           shift and go to state 95

state 148

    (60) args2 -> empty .

    RPAREN          reduce using rule 60 (args2 -> empty .)


state 149

    (53) idmvf3 -> LSBRA exp RSBRA .

    COMMA           reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    SEMICOLON       reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    EQUALS          reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    TIMES           reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    DIVIDE          reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    PLUS            reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    MINUS           reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    RSBRA           reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    RELOP           reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    AND             reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    OR              reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)
    RPAREN          reduce using rule 53 (idmvf3 -> LSBRA exp RSBRA .)


state 150

    (24) exlog3 -> AND exlog .

    RPAREN          reduce using rule 24 (exlog3 -> AND exlog .)
    SEMICOLON       reduce using rule 24 (exlog3 -> AND exlog .)


state 151

    (25) exlog3 -> OR exlog .

    RPAREN          reduce using rule 25 (exlog3 -> OR exlog .)
    SEMICOLON       reduce using rule 25 (exlog3 -> OR exlog .)


state 152

    (29) expresion2 -> RELOP exp .

    AND             reduce using rule 29 (expresion2 -> RELOP exp .)
    OR              reduce using rule 29 (expresion2 -> RELOP exp .)
    RPAREN          reduce using rule 29 (expresion2 -> RELOP exp .)
    SEMICOLON       reduce using rule 29 (expresion2 -> RELOP exp .)
    COMMA           reduce using rule 29 (expresion2 -> RELOP exp .)


state 153

    (64) funccall3 -> COMMA exp . funccall3
    (64) funccall3 -> . COMMA exp funccall3
    (65) funccall3 -> . empty
    (101) empty -> .

    COMMA           shift and go to state 134
    RPAREN          reduce using rule 101 (empty -> .)

    funccall3                      shift and go to state 165
    empty                          shift and go to state 135

state 154

    (66) condicion -> IF LPAREN exlog RPAREN . bloque condicion2
    (14) bloque -> . LBRA bloque2 RBRA

    LBRA            shift and go to state 167

    bloque                         shift and go to state 166

state 155

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON . exlog SEMICOLON asignacion RPAREN bloque
    (21) exlog -> . exlog2 expresion exlog3
    (22) exlog2 -> . NOT
    (23) exlog2 -> . empty
    (101) empty -> .

    NOT             shift and go to state 68
    LPAREN          reduce using rule 101 (empty -> .)
    PLUS            reduce using rule 101 (empty -> .)
    MINUS           reduce using rule 101 (empty -> .)
    NUMERIC         reduce using rule 101 (empty -> .)
    CHARACTER       reduce using rule 101 (empty -> .)
    LOGICAL         reduce using rule 101 (empty -> .)
    INTEGER         reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)

    exlog                          shift and go to state 168
    exlog2                         shift and go to state 67
    empty                          shift and go to state 69

state 156

    (81) escritura -> WRITE LPAREN interior RPAREN .

    SEMICOLON       reduce using rule 81 (escritura -> WRITE LPAREN interior RPAREN .)


state 157

    (82) interior -> expresion escritura2 .

    RPAREN          reduce using rule 82 (interior -> expresion escritura2 .)


state 158

    (84) escritura2 -> COMMA . interior
    (82) interior -> . expresion escritura2
    (83) interior -> . CHARACTER escritura2
    (27) expresion -> . exp expresion2
    (69) exp -> . term exp2
    (73) term -> . factor term2
    (77) factor -> . LPAREN exlog RPAREN
    (78) factor -> . PLUS data
    (79) factor -> . MINUS data
    (80) factor -> . data
    (39) data -> . NUMERIC
    (40) data -> . CHARACTER
    (41) data -> . LOGICAL
    (42) data -> . INTEGER
    (43) data -> . idmv
    (44) data -> . funccall
    (45) data -> . read
    (55) idmv -> . ID idmv2
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (86) read -> . READ LPAREN read2 RPAREN

    CHARACTER       shift and go to state 144
    LPAREN          shift and go to state 39
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NUMERIC         shift and go to state 43
    LOGICAL         shift and go to state 45
    INTEGER         shift and go to state 46
    ID              shift and go to state 50
    READ            shift and go to state 51

    interior                       shift and go to state 169
    expresion                      shift and go to state 143
    exp                            shift and go to state 105
    term                           shift and go to state 37
    factor                         shift and go to state 38
    data                           shift and go to state 41
    idmv                           shift and go to state 47
    funccall                       shift and go to state 48
    read                           shift and go to state 49

state 159

    (85) escritura2 -> empty .

    RPAREN          reduce using rule 85 (escritura2 -> empty .)


state 160

    (83) interior -> CHARACTER escritura2 .

    RPAREN          reduce using rule 83 (interior -> CHARACTER escritura2 .)


state 161

    (89) func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars . funcest RBRA
    (94) funcest -> . estatuto funcest
    (95) funcest -> . empty
    (30) estatuto -> . estatuto2 SEMICOLON
    (101) empty -> .
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    funcest                        shift and go to state 170
    estatuto                       shift and go to state 171
    empty                          shift and go to state 172
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 162

    (96) funcvars -> vars . funcvars
    (96) funcvars -> . vars funcvars
    (97) funcvars -> . empty
    (11) vars -> . type idmv vars2 SEMICOLON
    (101) empty -> .
    (17) type -> . BOOL
    (18) type -> . CHAR
    (19) type -> . INT
    (20) type -> . NUM

    IF              reduce using rule 101 (empty -> .)
    FOR             reduce using rule 101 (empty -> .)
    ID              reduce using rule 101 (empty -> .)
    READ            reduce using rule 101 (empty -> .)
    WRITE           reduce using rule 101 (empty -> .)
    RETURN          reduce using rule 101 (empty -> .)
    RBRA            reduce using rule 101 (empty -> .)
    BOOL            shift and go to state 9
    CHAR            shift and go to state 10
    INT             shift and go to state 11
    NUM             shift and go to state 12

    vars                           shift and go to state 162
    funcvars                       shift and go to state 173
    empty                          shift and go to state 163
    type                           shift and go to state 8

state 163

    (97) funcvars -> empty .

    IF              reduce using rule 97 (funcvars -> empty .)
    FOR             reduce using rule 97 (funcvars -> empty .)
    ID              reduce using rule 97 (funcvars -> empty .)
    READ            reduce using rule 97 (funcvars -> empty .)
    WRITE           reduce using rule 97 (funcvars -> empty .)
    RETURN          reduce using rule 97 (funcvars -> empty .)
    RBRA            reduce using rule 97 (funcvars -> empty .)


state 164

    (59) args2 -> COMMA args .

    RPAREN          reduce using rule 59 (args2 -> COMMA args .)


state 165

    (64) funccall3 -> COMMA exp funccall3 .

    RPAREN          reduce using rule 64 (funccall3 -> COMMA exp funccall3 .)


state 166

    (66) condicion -> IF LPAREN exlog RPAREN bloque . condicion2
    (67) condicion2 -> . ELSE bloque
    (68) condicion2 -> . empty
    (101) empty -> .

    ELSE            shift and go to state 175
    SEMICOLON       reduce using rule 101 (empty -> .)

    condicion2                     shift and go to state 174
    empty                          shift and go to state 176

state 167

    (14) bloque -> LBRA . bloque2 RBRA
    (15) bloque2 -> . empty
    (16) bloque2 -> . estatuto bloque2
    (101) empty -> .
    (30) estatuto -> . estatuto2 SEMICOLON
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    bloque2                        shift and go to state 177
    empty                          shift and go to state 178
    estatuto                       shift and go to state 179
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 168

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog . SEMICOLON asignacion RPAREN bloque

    SEMICOLON       shift and go to state 180


state 169

    (84) escritura2 -> COMMA interior .

    RPAREN          reduce using rule 84 (escritura2 -> COMMA interior .)


state 170

    (89) func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest . RBRA

    RBRA            shift and go to state 181


state 171

    (94) funcest -> estatuto . funcest
    (94) funcest -> . estatuto funcest
    (95) funcest -> . empty
    (30) estatuto -> . estatuto2 SEMICOLON
    (101) empty -> .
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    estatuto                       shift and go to state 171
    funcest                        shift and go to state 182
    empty                          shift and go to state 172
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 172

    (95) funcest -> empty .

    RBRA            reduce using rule 95 (funcest -> empty .)


state 173

    (96) funcvars -> vars funcvars .

    IF              reduce using rule 96 (funcvars -> vars funcvars .)
    FOR             reduce using rule 96 (funcvars -> vars funcvars .)
    ID              reduce using rule 96 (funcvars -> vars funcvars .)
    READ            reduce using rule 96 (funcvars -> vars funcvars .)
    WRITE           reduce using rule 96 (funcvars -> vars funcvars .)
    RETURN          reduce using rule 96 (funcvars -> vars funcvars .)
    RBRA            reduce using rule 96 (funcvars -> vars funcvars .)


state 174

    (66) condicion -> IF LPAREN exlog RPAREN bloque condicion2 .

    SEMICOLON       reduce using rule 66 (condicion -> IF LPAREN exlog RPAREN bloque condicion2 .)


state 175

    (67) condicion2 -> ELSE . bloque
    (14) bloque -> . LBRA bloque2 RBRA

    LBRA            shift and go to state 167

    bloque                         shift and go to state 183

state 176

    (68) condicion2 -> empty .

    SEMICOLON       reduce using rule 68 (condicion2 -> empty .)


state 177

    (14) bloque -> LBRA bloque2 . RBRA

    RBRA            shift and go to state 184


state 178

    (15) bloque2 -> empty .

    RBRA            reduce using rule 15 (bloque2 -> empty .)


state 179

    (16) bloque2 -> estatuto . bloque2
    (15) bloque2 -> . empty
    (16) bloque2 -> . estatuto bloque2
    (101) empty -> .
    (30) estatuto -> . estatuto2 SEMICOLON
    (31) estatuto2 -> . condicion
    (32) estatuto2 -> . ciclo
    (33) estatuto2 -> . funccall
    (34) estatuto2 -> . asignacion
    (35) estatuto2 -> . read
    (36) estatuto2 -> . escritura
    (37) estatuto2 -> . return
    (66) condicion -> . IF LPAREN exlog RPAREN bloque condicion2
    (98) ciclo -> . FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque
    (61) funccall -> . ID LPAREN funccall2 RPAREN
    (38) asignacion -> . idmv EQUALS exlog
    (86) read -> . READ LPAREN read2 RPAREN
    (81) escritura -> . WRITE LPAREN interior RPAREN
    (46) return -> . RETURN return2
    (55) idmv -> . ID idmv2

    RBRA            reduce using rule 101 (empty -> .)
    IF              shift and go to state 85
    FOR             shift and go to state 86
    ID              shift and go to state 87
    READ            shift and go to state 51
    WRITE           shift and go to state 89
    RETURN          shift and go to state 90

    estatuto                       shift and go to state 179
    bloque2                        shift and go to state 185
    empty                          shift and go to state 178
    estatuto2                      shift and go to state 77
    condicion                      shift and go to state 78
    ciclo                          shift and go to state 79
    funccall                       shift and go to state 80
    asignacion                     shift and go to state 81
    read                           shift and go to state 82
    escritura                      shift and go to state 83
    return                         shift and go to state 84
    idmv                           shift and go to state 88

state 180

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON . asignacion RPAREN bloque
    (38) asignacion -> . idmv EQUALS exlog
    (55) idmv -> . ID idmv2

    ID              shift and go to state 19

    asignacion                     shift and go to state 186
    idmv                           shift and go to state 88

state 181

    (89) func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA .

    FUNCTION        reduce using rule 89 (func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA .)
    MAIN            reduce using rule 89 (func -> FUNCTION functipo ID LPAREN funcargs RPAREN LBRA funcvars funcest RBRA .)


state 182

    (94) funcest -> estatuto funcest .

    RBRA            reduce using rule 94 (funcest -> estatuto funcest .)


state 183

    (67) condicion2 -> ELSE bloque .

    SEMICOLON       reduce using rule 67 (condicion2 -> ELSE bloque .)


state 184

    (14) bloque -> LBRA bloque2 RBRA .

    ELSE            reduce using rule 14 (bloque -> LBRA bloque2 RBRA .)
    SEMICOLON       reduce using rule 14 (bloque -> LBRA bloque2 RBRA .)


state 185

    (16) bloque2 -> estatuto bloque2 .

    RBRA            reduce using rule 16 (bloque2 -> estatuto bloque2 .)


state 186

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion . RPAREN bloque

    RPAREN          shift and go to state 187


state 187

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN . bloque
    (14) bloque -> . LBRA bloque2 RBRA

    LBRA            shift and go to state 167

    bloque                         shift and go to state 188

state 188

    (98) ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque .

    SEMICOLON       reduce using rule 98 (ciclo -> FOR LPAREN ciclo1 SEMICOLON exlog SEMICOLON asignacion RPAREN bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 144 resolved as shift
WARNING: reduce/reduce conflict in state 144 resolved using rule (data -> CHARACTER)
WARNING: rejected rule (empty -> <empty>) in state 144
